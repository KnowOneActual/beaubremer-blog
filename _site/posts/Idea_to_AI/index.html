<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>From Idea to AI: Building (and Securing) a Conversational Weather Bot | Beau Bremer&#39;s | Blog</title>
    <meta name="description" content="A deep dive into how I built a full-stack, conversational weather bot using JavaScript, the Gemini API, and Netlify Serverless Functions, including the security and deployment challenges I solved along the way." />
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Space+Grotesk:wght@400;700&display=swap" as="style" crossorigin="anonymous" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Space+Grotesk:wght@400;700&display=swap" rel="stylesheet" crossorigin="anonymous" />
    
    <link rel="icon" type="image/png" href="/img/favicon/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="/img/favicon/favicon.svg" />
<link rel="shortcut icon" href="/img/favicon/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/img/favicon/apple-touch-icon.png" />
<link rel="manifest" href="/img/favicon/site.webmanifest" />
<link rel="stylesheet" href="/assets/css/lite-yt-embed.css" />
</head>
<body class="bg-gray-950 text-white scroll-smooth flex flex-col min-h-screen">

    <header class="py-6 px-6 max-w-3xl mx-auto w-full">
        <div class="flex justify-between items-center">
            <div>
                <a href="/" class="text-2xl font-bold text-white hover:text-fuchsia-400 transition-colors">Beau Bremer&#39;s | Blog</a>
            </div>
            <nav>
              
                <a href="/" class="text-gray-300 hover:text-white transition-colors">← Back to Blog Home</a>
              
            </nav>
        </div>
    </header>

    <main class="max-w-3xl mx-auto py-12 px-6 flex-grow w-full">
        <div class="prose prose-invert lg:prose-xl max-w-none">
            <article>
    <header>
        <h1 class="text-5xl font-extrabold text-fuchsia-400 mb-4">From Idea to AI: Building (and Securing) a Conversational Weather Bot</h1>
        
            <p class="text-gray-400">
                <time datetime="2025-06-21T00:00:00.000Z">June 21, 2025</time>
            </p>
        
        
        
        
            <div class="mt-4">
                <span class="text-gray-400">Tagged in:</span>
                
                    
                        <a href="/tags/project/" class="inline-block bg-gray-800 text-fuchsia-300 rounded-full px-3 py-1 text-sm font-semibold ml-2 hover:bg-gray-700 transition-colors">#project</a>
                    
                
                    
                        <a href="/tags/javascript/" class="inline-block bg-gray-800 text-fuchsia-300 rounded-full px-3 py-1 text-sm font-semibold ml-2 hover:bg-gray-700 transition-colors">#javascript</a>
                    
                
                    
                        <a href="/tags/apis/" class="inline-block bg-gray-800 text-fuchsia-300 rounded-full px-3 py-1 text-sm font-semibold ml-2 hover:bg-gray-700 transition-colors">#apis</a>
                    
                
                    
                        <a href="/tags/serverless/" class="inline-block bg-gray-800 text-fuchsia-300 rounded-full px-3 py-1 text-sm font-semibold ml-2 hover:bg-gray-700 transition-colors">#serverless</a>
                    
                
                    
                        <a href="/tags/security/" class="inline-block bg-gray-800 text-fuchsia-300 rounded-full px-3 py-1 text-sm font-semibold ml-2 hover:bg-gray-700 transition-colors">#security</a>
                    
                
                    
                        <a href="/tags/case-study/" class="inline-block bg-gray-800 text-fuchsia-300 rounded-full px-3 py-1 text-sm font-semibold ml-2 hover:bg-gray-700 transition-colors">#case-study</a>
                    
                
            </div>
        
    </header>
    
    <hr class="border-gray-700 my-8">

    <p>I wanted a portfolio project that went beyond a simple static site—something that demonstrated a complete development cycle, from concept to a secure, deployed application. The idea? A conversational weather bot. Instead of just typing &quot;Chicago,&quot; a user could ask, &quot;What's the weather like in Chicago this afternoon?&quot; and get a natural-language answer.</p>
<p>This project became a practical exercise in modern web development, integrating multiple APIs and a serverless backend. More importantly, it was a journey through the real-world process of debugging and refinement—the skills that turn code into a reliable product.</p>
<h3>The Toolkit: Choosing the Right Tools</h3>
<p>The goal was a modern, intelligent, and secure application. I chose a tech stack where each component served a specific purpose, demonstrating a strategic approach to development.</p>
<ul>
<li><strong>Frontend:</strong> Plain HTML, JavaScript, and Tailwind CSS. I chose this to keep the frontend lightweight and fast, avoiding framework overhead for what was primarily a simple, clean UI.</li>
<li><strong>Intelligence:</strong> The <a href="https://ai.google.dev/">Gemini API</a> from Google. Its strength in natural language processing was perfect for the core task: turning a user's informal question into actionable data.</li>
<li><strong>Live Data:</strong> The <a href="https://openweathermap.org/api">OpenWeatherMap API</a>. A reliable and straightforward source for real-time, structured weather data.</li>
<li><strong>Database:</strong> <a href="https://firebase.google.com/docs/firestore">Google Firestore</a>. I needed a simple way to save conversation history, and Firestore's real-time capabilities and easy setup were ideal for this.</li>
<li><strong>Hosting &amp; Backend:</strong> <a href="https://www.netlify.com/">Netlify</a>. I opted for a serverless approach because it's cost-effective, scales automatically, and provides a secure environment for my secret API keys without needing to manage a dedicated server.</li>
</ul>
<h3>Part 1: The Blueprint - A Rapid Prototype</h3>
<p>The first step was getting a minimum viable product working. I built the chat interface with simple HTML, styled with Tailwind CSS for a clean look.</p>
<p>The initial UI structure was straightforward: a container for messages and a form for input.</p>
<pre><code class="language-html">&lt;div id=&quot;chat-window&quot; class=&quot;flex-1 p-6 overflow-y-auto&quot;&gt;
  &lt;/div&gt;

&lt;form id=&quot;chat-form&quot; class=&quot;flex items-center&quot;&gt;
  &lt;input type=&quot;text&quot; id=&quot;chat-input&quot; placeholder=&quot;Ask about the weather...&quot; autocomplete=&quot;off&quot;&gt;
  &lt;button type=&quot;submit&quot;&gt;Send&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<p>Initially, all the logic lived in a client-side JavaScript file. The logic followed three steps: identify the city using the Gemini API, fetch weather data from OpenWeatherMap, and then feed both back into Gemini to generate a human-friendly response. While this was great for quick prototyping, it had a critical security flaw that I planned to address after proving the concept.
Part 2: From Localhost to Live - The Inevitable Hurdles
Getting the prototype to run on a live website is where the real problem-solving began. Deploying to Netlify revealed a series of issues that required systematic debugging.
Challenge 1: The Bot Was Stuck on &quot;Connecting...&quot;
Investigation: The app worked locally but not when deployed. The browser console was clean, which suggested the issue wasn't a simple code error. I realized my local setup used a development server, but the live site had no database connection configured.
Solution: I created a production Firebase project and wired it up by adding the firebaseConfig object to my project. This was a classic &quot;dev vs. production&quot; environment mismatch, and it reinforced the need for explicit configuration for deployed services.
Challenge 2: Authentication and Security Policy Errors
Investigation: With the database configured, new errors appeared: a Content Security Policy (CSP) block against gstatic.com (a Google domain for Firebase) and an auth/admin-restricted-operation error from Firebase itself.
Solution: I solved this in two steps. First, I updated the netlify.toml file to explicitly allow scripts from gstatic.com in my CSP. Second, I diagnosed the auth error to mean that while my app was talking to Firebase, no users were authorized to perform actions. I enabled &quot;Anonymous sign-in&quot; in the Firebase console, creating a secure session for any visitor without requiring them to create an account.
Part 3: The Pro-Level Step - Securing API Keys
The most critical issue was that my API keys for Gemini and OpenWeatherMap were sitting in my public JavaScript file. Exposing API keys on the frontend is a critical security flaw. A malicious actor could steal them and run up enormous costs on my billing account or have them disabled for abuse. This is unacceptable for any real-world application.
The solution was to refactor the architecture, introducing a serverless function to act as a secure proxy.
The New, Secure Architecture:
Instead of the user's browser calling the APIs directly, it now makes a single, secure request to a backend function on my own site. This function then calls the external APIs using the keys, which are stored safely as environment variables on Netlify.
[Your Architecture Diagram Here]
(Suggestion: Create a simple diagram showing: Browser -&gt; Netlify Function -&gt; (Gemini API &amp; OpenWeatherMap API) -&gt; Browser. This visual is extremely effective for showing you understand the architecture.)
I created a Netlify Function in netlify/functions/weather.js. This function is the only part of the system that can access the secret keys.</p>
<p>JavaScript</p>
<p>// netlify/functions/weather.js</p>
<p>// Using node-fetch for making API calls in the Node.js environment
const fetch = require('node-fetch');</p>
<p>exports.handler = async function (event) {
// Only allow POST requests for security
if (event.httpMethod !== 'POST') {
return { statusCode: 405, body: 'Method Not Allowed' };
}</p>
<p>try {
const { userQuery } = JSON.parse(event.body);</p>
<p>// Get API keys from secure environment variables, never exposed to the client
const { WEATHER_API_KEY, GEMINI_API_KEY } = process.env;</p>
<p>// ... (Secure logic to call Gemini and OpenWeatherMap APIs) ...</p>
<p>// The function securely gets the data and formats a response
const botResponse = await getConversationalReply(userQuery);</p>
<p>return {
statusCode: 200,
body: JSON.stringify({ reply: botResponse }),
};</p>
<p>} catch (error) {
console.error(&quot;Netlify Function Error:&quot;, error);
return { statusCode: 500, body: JSON.stringify({ error: 'An internal server error occurred.' }) };
}
};</p>
<pre><code>

This serverless architecture completely mitigates the risk of exposing API keys while maintaining the same user experience.
Final Result and Key Takeaways
This project was a valuable exercise in building a full-stack application from the ground up. It demonstrates a practical approach to integrating third-party services, securing sensitive data, and—most importantly—systematically debugging the issues that arise when moving from a local machine to a live production environment.
</code></pre>

</article>
        </div>
    </main>

    <footer class="text-center py-6 bg-gray-900 text-gray-500">
        © 2025 Beau Bremer. All rights reserved. Have A Great Day and/or Night!
    </footer>
    <script src="/assets/js/lite-yt-embed.js"></script>
</body>
</html>