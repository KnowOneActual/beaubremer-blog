<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Git Commands I Actually Use Every Day (And Why) | Beau Bremer&#39;s | Blog</title>
    <meta name="description" content="A practical look at the small set of Git commands that actually matter in my day-to-day work." />
    <link rel="stylesheet" href="/css/style.css" />
    <link href="https://unpkg.com/prismjs@1.20.0/themes/prism-okaidia.css" rel="stylesheet">
    <link rel="me" href="https://mastodon.social/@grimburly">
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Space+Grotesk:wght@400;700&display=swap" as="style" crossorigin="anonymous" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Space+Grotesk:wght@400;700&display=swap" rel="stylesheet" crossorigin="anonymous" />
    
<link rel="icon" type="image/svg+xml" href="/img/favicon/favicon.svg" />
<link rel="icon" type="image/webp" href="/img/favicon/favicon-32x32.webp" sizes="32x32">
<link rel="icon" type="image/webp" href="/img/favicon/favicon-96x96.webp" sizes="96x96">
<link rel="icon" type="image/png" href="/img/favicon/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/png" href="/img/favicon/favicon-32x32.png" sizes="32x32" />
<link rel="apple-touch-icon" sizes="180x180" href="/img/favicon/apple-touch-icon.png" />
<link rel="manifest" href="/img/favicon/site.webmanifest" />
<link rel="shortcut icon" href="/img/favicon/favicon.ico" />
<link rel="stylesheet" href="/assets/css/lite-yt-embed.css" />
</head>
<body class="bg-gray-950 text-white scroll-smooth flex flex-col min-h-screen">

    <header class="py-6 px-6 max-w-3xl mx-auto w-full">
        <div class="flex justify-between items-center">
            <div>
                <a href="/" class="text-2xl font-bold text-white hover:text-fuchsia-400 transition-colors">Beau Bremer&#39;s | Blog</a>
            </div>
            <nav>
              
                <a href="/" class="text-gray-300 hover:text-white transition-colors">← Back to Blog Home</a>
              
            </nav>
        </div>
    </header>

    <main class="max-w-3xl mx-auto py-12 px-6 flex-grow w-full">
        <div class="prose prose-invert lg:prose-xl max-w-none">
            <article>
    <header>
        <h1 class="text-5xl font-extrabold text-fuchsia-400 mb-4">The Git Commands I Actually Use Every Day (And Why)</h1>
        
            <p class="text-gray-400">
                <time datetime="2026-01-10T00:00:00.000Z">January 10, 2026</time>
            </p>
        
        
        
        
            <div class="mt-4">
                <span class="text-gray-400">Tagged in:</span>
                
                    
                
                    
                        <a href="/tags/git/" class="inline-block bg-gray-800 text-fuchsia-300 rounded-full px-3 py-1 text-sm font-semibold ml-2 hover:bg-gray-700 transition-colors">#git</a>
                    
                
                    
                        <a href="/tags/tooling/" class="inline-block bg-gray-800 text-fuchsia-300 rounded-full px-3 py-1 text-sm font-semibold ml-2 hover:bg-gray-700 transition-colors">#tooling</a>
                    
                
            </div>
        
    </header>
    
    <hr class="border-gray-700 my-8">

    <h3>The Git Commands I Actually Use Every Day (And Why)</h3>
<p><strong>TL;DR:</strong> In this post, I walk through the handful of Git commands I actually use daily, how they fit into my workflow, and how they help me keep commits small, reviewable, and recoverable.</p>
<p>There are a lot of Git commands out there, but on a normal day, I only reach for a small handful. These are the ones that keep my work moving: checking what changed, making focused commits, and recovering from the occasional mistake.</p>
<p>This isn't a complete Git guide. It's the set of commands that live in my muscle memory, and what I use them for in real projects.</p>
<hr>
<h2>1. Seeing what changed</h2>
<p>Before I type any commit command, I want to know exactly what I'm about to do.</p>
<h3><code>git status</code></h3>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> status</code></pre>
<p>This is my &quot;what's going on?&quot; button. I run it:</p>
<ul>
<li>After pulling new changes, to see if I'm clean or mid-merge.</li>
<li>Before committing, to double-check which files are staged vs unstaged.</li>
<li>When something feels off, I just want to get my bearings.</li>
</ul>
<p>If I only used one Git command all day, it would probably be this one.</p>
<h3><code>git diff</code></h3>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">diff</span>
<span class="token function">git</span> <span class="token function">diff</span> <span class="token parameter variable">--staged</span></code></pre>
<p>I use plain <code>git diff</code> to see what I've changed but haven't staged yet, and <code>git diff --staged</code> to see what's actually going into the next commit.</p>
<p>Typical flow:</p>
<ol>
<li>Edit code.</li>
<li>Run <code>git diff</code> to scan through changes.</li>
<li>Stage only the parts that belong together.</li>
<li>Run <code>git diff --staged</code> to sanity check the commit before hitting enter.</li>
</ol>
<p>A small example: I once refactored a component and changed some unrelated logging while I was &quot;in there.&quot; When I ran <code>git diff</code>, it was obvious that the logging tweak didn't belong in the same commit as the refactor. I used <code>git add -p</code> to stage only the refactor hunks and left the logging change for a separate &quot;tidy up logs&quot; commit. That two-minute decision made the review simpler and kept the history cleaner.</p>
<hr>
<h2>2. Building clean commits</h2>
<p>Once I know what changed, I want my commits to be small and focused. That makes it easier to review, debug, and revert later.</p>
<h3><code>git add</code></h3>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> file.py
<span class="token function">git</span> <span class="token function">add</span> path/to/dir
<span class="token function">git</span> <span class="token function">add</span> <span class="token parameter variable">-p</span></code></pre>
<p>I rarely run <code>git add .</code> unless it's a very small change. Instead, I:</p>
<ul>
<li>Add specific files when changes are clearly grouped.</li>
<li>Use <code>git add -p</code> (patch mode) to split a file into meaningful chunks and only stage the hunks that belong in this commit.</li>
</ul>
<p>Patch mode is one of those &quot;hidden superpowers&quot; most people skip at first. Once you get used to it, it's hard to go back.</p>
<h3><code>git commit</code></h3>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"Short, clear message."</span>
<span class="token function">git</span> commit</code></pre>
<p>For simple changes, I'll use <code>-m</code>. For anything bigger, I skip the message flag and let Git open my editor so I can:</p>
<ul>
<li>Write a short subject line.</li>
<li>Add a bullet list or a couple of sentences with context if needed.</li>
</ul>
<p>I don't obsess over perfectly formatted commit messages, but I do try to answer: &quot;If I saw this 6 months from now, would I know what changed and why?&quot;</p>
<hr>
<h2>3. Staying in sync with the remote</h2>
<p>Most of my work happens on branches, but the pattern is the same whether I'm on <code>main</code> or a feature branch.</p>
<h3><code>git pull</code> and <code>git fetch</code></h3>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> pull
<span class="token function">git</span> fetch</code></pre>
<p>I use:</p>
<ul>
<li><code>git pull</code> when I just want &quot;get me up to date,&quot; and I know I haven't made local changes that will conflict.</li>
<li><code>git fetch</code> when I want to see what changed on the remote without touching my working tree, especially before a rebase or when I'm checking out someone else's branch.</li>
</ul>
<h3><code>git push</code></h3>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> push
<span class="token function">git</span> push <span class="token parameter variable">-u</span> origin feature/my-branch</code></pre>
<p>I push early and often, especially on feature branches. That gives me:</p>
<ul>
<li>A backup if my machine dies.</li>
<li>A way to hop devices without copying files.</li>
<li>A clear history of work in progress.</li>
</ul>
<p>On a new branch, I'll use <code>-u</code> once so future pushes can just be <code>git push</code>.</p>
<hr>
<h2>4. Working with branches</h2>
<p>Branches are how I keep experiments and features from getting tangled.</p>
<h3><code>git branch</code> and <code>git switch</code> / <code>git checkout</code></h3>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> branch
<span class="token function">git</span> branch feature/my-idea
<span class="token function">git</span> switch feature/my-idea
<span class="token comment"># or</span>
<span class="token function">git</span> checkout feature/my-idea</code></pre>
<p>My everyday moves are:</p>
<ul>
<li><code>git branch</code> to list what exists and see where I am.</li>
<li>Create a branch for anything more than a tiny fix.</li>
<li>Keep branch names descriptive enough that &quot;future me&quot; and coworkers instantly know what they're for.</li>
</ul>
<p>I don't worry about clever names; clear and boring wins.</p>
<h3><code>git merge</code></h3>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> switch main
<span class="token function">git</span> pull
<span class="token function">git</span> merge feature/my-idea</code></pre>
<p>I use merge when I'm bringing a finished feature into <code>main</code> or when I want to incorporate the latest <code>main</code> changes into my branch without rewriting history.</p>
<p>If a merge conflict appears, I let my editor or diff tool help resolve it, then:</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token operator">&lt;</span>fixed-files<span class="token operator">></span>
<span class="token function">git</span> commit</code></pre>
<hr>
<h2>5. Fixing mistakes (without panicking)</h2>
<p>Even with the best intentions, I stage the wrong thing or type the wrong message. These are the recovery commands I actually trust myself to use.</p>
<h3><code>git restore</code> (resetting a file)</h3>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> restore path/to/file
<span class="token comment"># older style:</span>
<span class="token function">git</span> checkout -- path/to/file</code></pre>
<p>I use this when I realize &quot;I don't actually want any of the changes in this file.&quot;</p>
<p>It drops the local modifications and returns the file to the last committed state. I double-check with <code>git status</code> before running it, just to make sure I won't lose something important.</p>
<p>I'm careful with <code>git restore</code> because it really does throw away local changes. I mostly use it on generated files or quick experiments where I know I don't care about the edits. When I'm unsure, I'll copy the code somewhere else before restoring, or just leave the file alone and clean it up once I'm certain.</p>
<h3><code>git reset HEAD</code> (unstaging)</h3>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> reset HEAD path/to/file</code></pre>
<p>This one's for: &quot;I staged too much, but I still want to keep the changes.&quot;</p>
<p>It moves the file from staged back to unstaged, so I can restage only what belongs in this commit, often paired with <code>git add -p</code>.</p>
<p>My most common mistake is staging a file that doesn't actually belong to the change I'm working on, usually some config file or scratch notes I forgot about. I'll notice it in <code>git status</code>, then run <code>git reset HEAD path/to/file</code> to unstage it. The changes stay in my working tree, so I don't lose anything; I just keep them out of the commit until I'm ready.</p>
<h3><code>git commit-- amend</code></h3>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> commit <span class="token parameter variable">--amend</span>
<span class="token function">git</span> commit <span class="token parameter variable">--amend</span> <span class="token parameter variable">-m</span> <span class="token string">"Better message."</span></code></pre>
<p>I use <code>--amend</code> when:</p>
<ul>
<li>I just committed and immediately spot a typo in the message.</li>
<li>I forgot to include one small file.</li>
</ul>
<p>I only amend commits that haven't been pushed yet, so I don't rewrite history that other people might already have.</p>
<hr>
<h2>6. Looking back in time</h2>
<p>When something breaks or behaves strangely, I often need to see how we got here.</p>
<h3><code>git log</code></h3>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> log
<span class="token function">git</span> log <span class="token parameter variable">--oneline</span> <span class="token parameter variable">--graph</span> <span class="token parameter variable">--decorate</span> <span class="token parameter variable">--all</span></code></pre>
<p>I use plain <code>git log</code> if I'm just scanning recent commits. For a better overview, I have an alias (or just type the full command) with <code>--oneline --graph --decorate --all</code> to see branches and merges as a visual graph.</p>
<p>This helps when:</p>
<ul>
<li>I'm trying to find where a bug might have been introduced.</li>
<li>I'm picking a commit to revert or cherry-pick.</li>
<li>I want to understand the story of a feature branch.</li>
</ul>
<hr>
<h2>7. How this looks in a real day</h2>
<p>On a typical small feature, my actual sequence looks something like this:</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> switch <span class="token parameter variable">-c</span> feature/new-link-page
<span class="token comment"># do some work</span>
<span class="token function">git</span> status
<span class="token function">git</span> <span class="token function">diff</span>
<span class="token function">git</span> <span class="token function">add</span> <span class="token parameter variable">-p</span>
<span class="token function">git</span> <span class="token function">diff</span> <span class="token parameter variable">--staged</span>
<span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"Add basic link-in-bio layout."</span>
<span class="token function">git</span> pull   <span class="token comment"># if needed</span>
<span class="token function">git</span> push <span class="token parameter variable">-u</span> origin feature/new-link-page</code></pre>
<p>Then, after review and any fixes:</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> switch main
<span class="token function">git</span> pull
<span class="token function">git</span> merge feature/new-link-page
<span class="token function">git</span> push</code></pre>
<p>If I mess up along the way:</p>
<ul>
<li><code>git reset HEAD file</code> to unstage something.</li>
<li><code>git restore file</code> to throw away a bad change.</li>
<li><code>git commit --amend</code> to fix the last commit before pushing.</li>
</ul>
<p>This is pretty close to how I work on real tasks: pick up a ticket or idea, branch off, make a small set of changes, review with <code>git diff</code>, commit, then push. If I realize the change is bigger than I thought, I'll split it into a couple of focused commits instead of one giant &quot;everything&quot; commit. It keeps debugging and code review much calmer.</p>
<hr>
<h2>If you want to go deeper</h2>
<p>If you're newer to Git or want a more structured walkthrough, you might like these related posts:</p>
<ul>
<li><a href="/posts/essential_git%20part_1/">Essential Git: Part 1</a> – a more step-by-step look at the core concepts and commands.</li>
<li><a href="/posts/mastering_gitignore_a_complete_guide_to_a_cleaner_git_repo/">Getting a handle on.gitignore: A Guide to a Cleaner Git Repo</a> – how I keep junk and secrets out of my repos.</li>
</ul>
<p>Together with this post, they cover the Git concepts and habits I rely on most days.</p>

</article>
        </div>
    </main>

    <footer class="text-center py-6 bg-gray-950 text-gray-500">
    <div class="mb-2">
      <a href="https://blog.beaubremer.com/" target="_blank" class="hover:text-fuchsia-400 mx-2">Blog Home</a>
      <a href="https://github.com/KnowOneActual" target="_blank" class="hover:text-fuchsia-400 mx-2">GitHub</a>
     </div>
    <p>© 2026 Beau Bremer. Stay bold, keep creating, and rock on! All rights reserved.
    </p>
  </footer>
    <script src="/assets/js/lite-yt-embed.js"></script>
</body>
</html>